<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HiPS client for Python : A GSoC project</title><link>/</link><description></description><atom:link href="/feeds/gsoc.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 31 May 2017 19:39:00 +0500</lastBuildDate><item><title>An overview of Hierarchical progressive surveys (HiPS) and the HEALPix framework</title><link>/an-overview-of-hierarchical-progressive-surveys-hips-and-the-healpix-framework.html</link><description>&lt;p&gt;HiPS utilizes the HEALPix framework and uses it for mapping a sphere (in this case, part of a sky) and compiles / transforms it into &lt;a href="#hips-tiles"&gt;tiles&lt;/a&gt; and &lt;a href="#hips-pixels"&gt;pixels&lt;/a&gt;. Of course, this is in context of astronomical data. HiPS emphasizes on usability thus it tries abstract the scientific details while preserving them. This can be further built upon for statistical analysis of large datasets. Thus, first a brief overview of HEALPix is given below before moving onto HiPS.&lt;/p&gt;
&lt;h3&gt;Introduction to HEALPix&lt;/h3&gt;
&lt;p&gt;HEALPix, an acronym of 'Hierarchical Equal Area isoLatitude Pixelization of a sphere', is a framework for discretizing high resolution data. The software is available in C, C++, Fortran90, IDL, Java, and Python. It extends a data structure (with a library), for each language. The main features provided by the software are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pixel manipulation&lt;/li&gt;
&lt;li&gt;Spherical Harmonics Transforms&lt;/li&gt;
&lt;li&gt;Visualization&lt;/li&gt;
&lt;li&gt;Input / Output (supports FITS files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a nutshell, the pixelization procedure subdivides a spherical sphere in which each pixel is equidistant from the origin - meaning it covers the same surface area. This produces a HEALPix grid, whose interesting property is that pixels are distributed on lines of constant latitude. Due to this iso-latitude distribution of pixels the complexity for computing integrals over each harmonics is N&lt;sup&gt;1/2&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;HEALPix provides a standard format on how to store data in FITS files.  There are numerous software packages that can work with HEALPix data. For this project, &lt;code&gt;healpy&lt;/code&gt; will be used which is built on the HEALPix C++ package. But there are others, e.g. in Aladin Lite. The main functionality needed for this project is HEALPix pixel index to sky coordinate transformation (back and forth), and one or two methods to list HEALPix pixels in a given region of the sky (e.g. &lt;code&gt;query_disc&lt;/code&gt; from &lt;code&gt;healpy&lt;/code&gt;).&lt;/p&gt;
&lt;h4&gt;Pixel numbering schemes&lt;/h4&gt;
&lt;p&gt;HEALPix provides two numbering schemes for pixels, namely the &lt;strong&gt;RING scheme&lt;/strong&gt; and &lt;strong&gt;NESTED scheme&lt;/strong&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RING scheme&lt;/strong&gt;
In this scheme the pixels are counted down from north to south along each iso-latitude ring.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NESTED scheme&lt;/strong&gt;
 This scheme arranges the pixels into 12 tree structures with respect to their base-resolution pixels.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="HEALPix projection" src="{filename}https://github.com/adl1995/HIPS-to-Py/blob/master/images/HEALPix_projection_SW.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Introduction to HiPS&lt;/h3&gt;
&lt;p&gt;HiPS is the hierarchical tiling mechanism which allows one to access, visualize and browse seamlessly image, catalogue and cube data. The original HiPS paper can be found &lt;a href="https://arxiv.org/pdf/1505.02291.pdf"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;HiPS working&lt;/h3&gt;
&lt;p&gt;The multi-resolution representation of original images provides the basis for visualizing data in a progressive way as the pixels that are required for a given view can be accessed through pre-computed HEALPix maps, and the nested pixel numbering scheme provides a simple hierarchical indexing system that encodes pixel inheritance across different orders.&lt;/p&gt;
&lt;p&gt;HiPS scheme groups pixels into different tiles. The general relationship between tiles and pixels is that a tile with &lt;code&gt;n-tile&lt;/code&gt; pixels along each side forms a HEALPix mesh of order k&lt;sup&gt;tile&lt;/sup&gt;. Tiles store map information from HEALPix. These tiles are presented as square arrays and it is possible to store them in different file formats. The files are organized into different directories. Here tiles are used as files and tile orders are used for grouping data in directories - all following a naming convention. For more information on the method on file storage, &lt;a href="http://aladin.unistra.fr/hips/hipsdoc.pdf"&gt;this&lt;/a&gt; document can be viewed, written by Pierre Fernique.&lt;/p&gt;
&lt;h3&gt;HiPS pixels&lt;/h3&gt;
&lt;p&gt;Using the header &lt;code&gt;hips_pixel_bitpix&lt;/code&gt; the HiPS pixels are stored in BITPIX code. &lt;code&gt;hips_pixel_bitpix&lt;/code&gt; refers to the data type used to store the FITS tile (a value of 8 means 8-bits integers, -32 means simple floating points, -64 double precision floating points).&lt;/p&gt;
&lt;p&gt;This is usually the same value as the BITPIX value of the original images (described in keyword data_pixel_bitpix), but might be different, notably for HiPS built from heterogeneous origins.&lt;/p&gt;
&lt;p&gt;The BITPIX value is always present in the HiPS FITS tiles.&lt;/p&gt;
&lt;h3&gt;HiPS tiles&lt;/h3&gt;
&lt;p&gt;As it is cumbersome to transfer each pixel (essentially a file), so HiPS scheme groups pixels into different tiles. The general relationship between the tiles and pixels is that a tile with &lt;em&gt;n&lt;/em&gt;-tile pixels along each
side forms a HEALPix mesh of order of &lt;em&gt;k&lt;/em&gt;-tile. A HiPS tile is show below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A HiPS tile" src="https://github.com/adl1995/HIPS-to-Py/blob/master/images/hips-tile.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;HiPS images&lt;/h3&gt;
&lt;p&gt;The way HiPS represents images is by resampling them onto a HEALPix grid at the maximum desired order, say k&lt;sup&gt;max&lt;/sup&gt;. Then it generates tile images for tile orders. When mosaicking / stitching images, the angular resolution is taken into account. There are various methods for filling the data region when stitching images and dealing with background difference. The k&lt;sup&gt;max&lt;/sup&gt; chosen earlier determines minimum pixel size which is near to the angular pixel size or the resolution of original data.&lt;/p&gt;
&lt;p&gt;Next important thing is whether to emphasize on &lt;code&gt;display quality&lt;/code&gt; or &lt;code&gt;photometric accuracy&lt;/code&gt;, which depends on our use case. Image encoding can be done either in &lt;strong&gt;FITS&lt;/strong&gt;, &lt;strong&gt;PNG&lt;/strong&gt;, or &lt;strong&gt;JPG&lt;/strong&gt; file format. For most cases it is enough to only generate FITS and PNG files. The lowest order pixel values correspond to a large area of the sky. The HiPS indexing structure takes care of mapping correct tiles onto a display.&lt;/p&gt;
&lt;p&gt;HiPS generation for huge amounts of data such as the Hubble Space Telescope requires planning of system growth.&lt;/p&gt;
&lt;h3&gt;HiPS catalogues&lt;/h3&gt;
&lt;p&gt;A HiPS catalogue contains the RA / DEC coordinates stored in a TSV file. The data is ASCII tab separated and is organized in various directories the same way as HiPS images.&lt;/p&gt;
&lt;h3&gt;Google Summer of Code project&lt;/h3&gt;
&lt;p&gt;I have been selected for creating this package along with two mentors, &lt;a href="https://github.com/cdeil"&gt;Christoph Deil&lt;/a&gt; and  &lt;a href="https://github.com/tboch"&gt;Thomas Boch&lt;/a&gt;. My GSoC application can be found &lt;a href="https://github.com/adl1995/HIPS-to-Py/blob/master/documents/application.md"&gt;here&lt;/a&gt;. The goal of this project is to design and create a Python client for Hierarchical Progressive Surveys (HiPS). The library will extend a low and high level API for exploring and creating WCS / HEALPix images. Currently, there are other clients built using HiPS, such as Aladin and Aladin Lite, but they are written in Java and JavaScript, respectively. After the trivial functionality is complete, additional features such as measuring fluxes and overplotting multi-wavelength data will also be added. The code repository for this project can be found &lt;a href="https://github.com/hipspy/hips"&gt;here&lt;/a&gt;.  If anyone has any questions or suggestions regarding the package, they are encouraged to open issues. If you want to help us build the package or add extra features onto it, please upen up a pull request.&lt;/p&gt;
&lt;p&gt;The coding period is about to begin. My future blog posts will be based around this topic.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adeel Ahmad</dc:creator><pubDate>Wed, 31 May 2017 19:39:00 +0500</pubDate><guid>tag:,2017-05-31:an-overview-of-hierarchical-progressive-surveys-hips-and-the-healpix-framework.html</guid></item><item><title>A comparison of response times using URLLib, GRequests, and asyncio</title><link>/a-comparison-of-response-times-using-urllib-grequests-and-asyncio.html</link><description>&lt;p&gt;For the HiPS client as multiple tiles have to be fetched for time efficiency, concurrency has to be achieved. So, a comparison was done utilizing Python's &lt;code&gt;threading&lt;/code&gt; library. The elapsed time was calculated using &lt;code&gt;time&lt;/code&gt;. For fetching the tiles &lt;code&gt;urllib&lt;/code&gt;, &lt;code&gt;grequests&lt;/code&gt;, &lt;code&gt;aiohttp&lt;/code&gt;, &lt;code&gt;asyncio&lt;/code&gt; were used. The survey chosen was &lt;code&gt;alasky.u-strasbg.fr&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;For fetching 10 tiles, it took the following mentioned time (in seconds):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;without&lt;/span&gt; &lt;span class="n"&gt;concurrency&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;3.5430831909179688&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;concurrency&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;0.388397216796875&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;aiohttp&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;0.3900480270385742&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;GRequests&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.6238431930541992&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Similarly, for fetching 100 tiles, it took:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;without&lt;/span&gt; &lt;span class="n"&gt;concurrency&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;37.7027428150177&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;concurrency&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;5.575664043426514&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;URLLib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;aiohttp&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="mf"&gt;2.4697625637054443&lt;/span&gt;
&lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;GRequests&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;4.273705244064331&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The pros of &lt;code&gt;grequests&lt;/code&gt; is that it takes less time when large number of requests have to be sent. But &lt;code&gt;urllib&lt;/code&gt; (with threading) gives a better response time when requests are numerous.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;aiohttp&lt;/code&gt; with &lt;code&gt;asyncio&lt;/code&gt; seems to be the best option. Its response time is almost 50% less than &lt;code&gt;grequests&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The full source code can be found &lt;a href="https://github.com/adl1995/HIPS-to-Py/blob/master/examples/fetch-tiles-threaded.py"&gt;here&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adeel Ahmad</dc:creator><pubDate>Tue, 09 May 2017 15:54:00 +0500</pubDate><guid>tag:,2017-05-09:a-comparison-of-response-times-using-urllib-grequests-and-asyncio.html</guid></item><item><title>My First Article</title><link>/my-first-article.html</link><description>&lt;p&gt;Hello World!&lt;/p&gt;
&lt;p&gt;This blog will be extensively used for posting GSoC updates, apart from other technical ramblings.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adeel Ahmad</dc:creator><pubDate>Sun, 19 Mar 2017 22:45:00 +0500</pubDate><guid>tag:,2017-03-19:my-first-article.html</guid></item></channel></rss>